function distance(p1, p2) {
  return sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
}

function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}


function find_maxmin(arr) {
  let max = arr[0][0];
  let min = arr[0][0];
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      if (arr[i][j]!=Infinity && arr[i][j] > max) { max = arr[i][j]; }
      if (arr[i][j] < min) { min = arr[i][j]; }
    }
  }
  if (abs(min-max)<=0.1) { max = min + 1; }
  return {max: max, min: min};
}

function potential(point, source){
  let a = 1;
  let r = distance(point, source)/20;
  // return -50*((r-1)**2)*exp(-(r-1)/a)/(a**2)
  if (r>1 && r<2) { return -1; }
  else { return 0; }
}

class SegmentObstacle {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = distance(p1, p2);
  }

  draw() {
    line(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
  }

  minDistToSegment(p) {
    let dot1 = dot({x: p.x - this.p1.x, y: p.y - this.p1.y}, {x: this.p2.x - this.p1.x, y: this.p2.y - this.p1.y});
    if (dot1 <= 0) {
      return distance(p, this.p1);
    }
    let dot2 = dot({x: p.x - this.p2.x, y: p.y - this.p2.y}, {x: this.p1.x - this.p2.x, y: this.p1.y - this.p2.y});
    if (dot2 <= 0) {
      return distance(p, this.p2);
    }
    let distToLine = abs((this.p2.x - this.p1.x)*(p.y - this.p1.y) - (this.p2.y - this.p1.y)*(p.x - this.p1.x)) / this.length;
    return distToLine;
  }
}

class Pen {
  constructor(startingPos, startingDir, forwardSpeed, turning_speed, forward_lookahead, turning_lookahead) {
    this.head_pos = startingPos; // pixels
    this.head_dir = startingDir; // degrees. 0 is right and then counter-clockwise
    
    this.forwardSpeed = forwardSpeed; // pixels per frame
    this.turning_speed = turning_speed; // degrees per frame
    
    this.forward_lookahead = forward_lookahead;
    this.turning_lookahead = turning_lookahead;
    
    this.points = [startingPos];
  }

  updatePen(potential_map) {
    // check the potential values at distance head_speed and angel +10, 0, -10 degrees from the pen head
    let pots = [];
    let n = 5;
    for (let d = -this.turning_lookahead; d <= this.turning_lookahead; d += this.turning_lookahead*2/n) {
      let p = { // point to look at
        x: this.head_pos.x + this.forward_lookahead*cos(this.head_dir + d),
        y: this.head_pos.y + this.forward_lookahead*sin(this.head_dir + d)
      };
      
      let x = floor(p.x/scale); let y = floor(p.y/scale);
      if (x >= 0 && x < width/scale && y >= 0 && y < height/scale) {
        pots.push(potential_map[x][y]);
      } else { pots.push(Infinity); }
    }
    // then go to the minimum potential value
    let maxmin = find_maxmin(pots);
    if (maxmin.min - maxmin.max != 0) {
      this.head_dir += map(pots.indexOf(min(pots)), 0, n, -this.turning_speed, this.turning_speed);
    } else {
      this.head_dir += random(-this.turning_speed, this.turning_speed-2);
    }
    // this.head_dir += map(pots.indexOf(min(pots)), 0, n, -this.turning_speed, this.turning_speed);
    // update head position
    this.head_pos.x += this.forwardSpeed * cos(this.head_dir);
    this.head_pos.y += this.forwardSpeed * sin(this.head_dir);
    // add new head position to points array
    this.points.push({x: this.head_pos.x, y: this.head_pos.y});
  }

  drawPen() {
    fill(255, 0, 0);
    stroke(255, 0, 0);
    // draw pen drawing
    for (let i = 1; i < this.points.length - 1; i++) {
      let p1 = this.points[i];
      let p2 = this.points[i + 1];
      line(p1.x, p1.y, p2.x, p2.y);
    }
    // draw head as a triangle
    push();
    translate(this.head_pos.x, this.head_pos.y);
    rotate(this.head_dir);
    triangle(10, 0, 0, 5, 0, -5);
    pop();
  }
}









let pen; // the pen object
let obstacles = []; // array of obstacles
let scale = 5; // scale of the potential map
let potential_map = []; // 2d array of potential values (one value every scale pixels)

function setup() {
  createCanvas(400, 400);
  angleMode(DEGREES);
  pen = new Pen({x: 200, y: 200}, 0.0, 1.0, 10.0, 10.0, 40.0);

  let obstacle1 = new SegmentObstacle({x: 350, y: 100}, {x: 300, y: 300});
  let obstacle2 = new SegmentObstacle({x: 100, y: 300}, {x: 300, y: 300});
  let obstacle3 = new SegmentObstacle({x: 100, y: 50}, {x: 300, y: 100});
  let obstacle4 = new SegmentObstacle({x: 100, y: 50}, {x: 100, y: 300});
  let obstacle5 = new SegmentObstacle({x: 50, y: 50},{x: 50, y: 50} );
  obstacles = [obstacle1, obstacle2, obstacle3, obstacle4, obstacle5];
  // obstacles = [];
  
  // create a empty potential map
  for (let i = 0; i < width/scale; i++) {
    potential_map.push([]);
    for (let j = 0; j < height/scale; j++) {
      potential_map[i].push(0);
    }
  }
  // fill it from potentials generated by obstacles
  let obstacle_step_size = 20;
  for (let i = 0; i < width/scale; i++) {
    for (let j = 0; j < height/scale; j++) {
      for (let n = 0; n < obstacles.length; n++) {
        for (let k = 0; k < obstacle_step_size; k++) {
        // span obstacle with 10 points
        let source = {x: map(k, 0, obstacle_step_size, obstacles[n].p1.x, obstacles[n].p2.x), y: map(k, 0, obstacle_step_size, obstacles[n].p1.y, obstacles[n].p2.y)};
        let p = {x: i*scale, y: j*scale};
        potential_map[i][j] += potential(p, source);
       }
      }
    }
  }

  print(potential_map);
}


let n_iters = 1;
let currenti = 0;

function draw() {
  n_iters ++;
  frameRate(60);
  // ============ Update
  // update pen
  pen.updatePen(potential_map);
  // // update potential
  // if (n_iters % 120 == 0) {
  //   for (let i = 0; i < width/scale; i++) {
  //     for (let j = 0; j < height/scale; j++) {
  //       // loop over 1 every ten points of the pen track
  //       for (let n = currenti; n < pen.points.length; n+=10) {
  //         let p = {x: i*scale, y: j*scale};
  //         potential_map[i][j] += potential(p, pen.points[n]);
  //       }
  //     }
  //   }
  //   print(potential_map);
  //   currenti = pen.points.length;
  // }
  
  // ============ Draw
  // draw potential map
  // find max e min for color mapping
  let maxmin = find_maxmin(potential_map);
  // draw potential map
  noStroke();
  for (let i = 0; i < width/scale; i++) {
    for (let j = 0; j < height/scale; j++) {
      let c = map(potential_map[i][j], maxmin.min, maxmin.max, 0, 255);
      fill(c);
      rect(i*scale, j*scale, scale, scale);
    }
  }
  // draw pen
  pen.drawPen();
  // draw obstacles
  // for (let i = 0; i < obstacles.length; i++) { obstacles[i].draw(); }
}