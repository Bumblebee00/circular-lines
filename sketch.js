function distance(p1, p2) {
  return sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
}

function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}


function find_maxmin(arr) {
  let max = arr[0][0];
  let min = arr[0][0];
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      if (arr[i][j]!=Infinity && arr[i][j] > max) { max = arr[i][j]; }
      if (arr[i][j] < min) { min = arr[i][j]; }
    }
  }
  return {max: max, min: min};
}

function potential(point, source){
  let r = distance(point, source)/50;
  return -5*r*exp(-2*r);
}

class SegmentObstacle {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = distance(p1, p2);
  }

  draw() {
    line(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
  }

  minDistToSegment(p) {
    let dot1 = dot({x: p.x - this.p1.x, y: p.y - this.p1.y}, {x: this.p2.x - this.p1.x, y: this.p2.y - this.p1.y});
    if (dot1 <= 0) {
      return distance(p, this.p1);
    }
    let dot2 = dot({x: p.x - this.p2.x, y: p.y - this.p2.y}, {x: this.p1.x - this.p2.x, y: this.p1.y - this.p2.y});
    if (dot2 <= 0) {
      return distance(p, this.p2);
    }
    let distToLine = abs((this.p2.x - this.p1.x)*(p.y - this.p1.y) - (this.p2.y - this.p1.y)*(p.x - this.p1.x)) / this.length;
    return distToLine;
  }
}

class Pen {
  constructor(startingPos, startingSpeed, startingDir) {
    this.head_pos = startingPos; // pixels
    this.head_dir = startingDir; // degrees. 0 is right and then counter-clockwise
    this.ang_dir = 1; // 1 or -1
    this.time_last_changed_dir = millis();
    this.head_speed = startingSpeed; // pixels per frame
    this.points = [startingPos]; // array of points that the pen has drawn
  }

  updatePen(obstacles) {
    let delta_total = (noise(0.05 * frameCount)-0.5)*10;
    for (let i = 0; i < obstacles.length; i++) {
      let x = obstacles[i].minDistToSegment(this.head_pos);
      let s = i%2 == 0 ? 1 : -1;
      delta_total += s*100/ (x + 1);
    }

    // if (delta_total < 1 && millis() - this.time_last_changed_dir > 3000){
    //   this.ang_dir = -this.ang_dir;
    //   this.time_last_changed_dir = millis();
    //   console.log("changed direction");
    // }
    this.head_dir += this.ang_dir * delta_total;

    // update head position
    this.head_pos.x += this.head_speed * cos(this.head_dir);
    this.head_pos.y += this.head_speed * sin(this.head_dir);
    // add new head position to points array
    this.points.push({x: this.head_pos.x, y: this.head_pos.y});
  }

  drawPen() {
    fill(255, 0, 0);
    stroke(255, 0, 0);
    // draw pen drawing
    for (let i = 1; i < this.points.length - 1; i++) {
      let p1 = this.points[i];
      let p2 = this.points[i + 1];
      line(p1.x, p1.y, p2.x, p2.y);
    }
    // draw head as a triangle
    push();
    translate(this.head_pos.x, this.head_pos.y);
    rotate(this.head_dir);
    triangle(10, 0, 0, 5, 0, -5);
    pop();
  }
}

let pen; // the pen object
let obstacles = []; // array of obstacles
let scale = 5; // scale of the potential map
let potential_map = []; // 2d array of potential values (one value every scale pixels)

function setup() {
  createCanvas(400, 400);
  angleMode(DEGREES);
  let obstacle1 = new SegmentObstacle({x: 300, y: 100}, {x: 300, y: 300});
  let obstacle2 = new SegmentObstacle({x: 100, y: 300}, {x: 300, y: 300});
  let obstacle3 = new SegmentObstacle({x: 100, y: 100}, {x: 100, y: 300});
  let obstacle4 = new SegmentObstacle({x: 100, y: 100}, {x: 300, y: 100});
  obstacles = [obstacle1, obstacle2, obstacle3, obstacle4];
  pen = new Pen({x: 200, y: 200}, 1, 0);
  // create a empty potential map
  for (let i = 0; i < width/scale; i++) {
    potential_map.push([]);
    for (let j = 0; j < height/scale; j++) {
      potential_map[i].push(0);
    }
  }
  // fill it from potentials generated by obstacles
  let obstacle_step_size = 20;
  for (let i = 0; i < width/scale; i++) {
    for (let j = 0; j < height/scale; j++) {
      for (let n = 0; n < obstacles.length; n++) {
        for (let k = 0; k < obstacle_step_size; k++) {
        // span obstacle with 10 points
        let source = {x: map(k, 0, obstacle_step_size, obstacles[n].p1.x, obstacles[n].p2.x), y: map(k, 0, obstacle_step_size, obstacles[n].p1.y, obstacles[n].p2.y)};
        let p = {x: i*scale, y: j*scale};
        potential_map[i][j] += potential(p, source);
      }
      }
    }
  }

  print(potential_map);
}

function draw() {
  // ============ Update
  pen.updatePen(obstacles);
  
  // ============ Draw
  // draw potential map
  // find max e min for color mapping
  let maxmin = find_maxmin(potential_map);
  // draw potential map
  noStroke();
  for (let i = 0; i < width/scale; i++) {
    for (let j = 0; j < height/scale; j++) {
      let c = map(potential_map[i][j], maxmin.min, maxmin.max, 0, 255);
      fill(c);
      rect(i*scale, j*scale, scale, scale);
    }
  }
  // draw pen
  pen.drawPen();
  // draw obstacles
  for (let i = 0; i < obstacles.length; i++) { obstacles[i].draw(); }
}